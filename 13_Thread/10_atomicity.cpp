// 원자성(atomicity)
/*  
    코드가 생각한 순서대로 작동하지 않을 수도 있다 (단일 쓰레드 관점에서) 
    결과값이 동일하다면 컴파일러와 CPU는 명령어의 순서를 재배치 할 수 있다.
    문제는 마음대로 메모리 접근 명령어의 순서를 재배치 한다면 멀티 쓰레드 환경에서 결과가 달라질 수도 있다는 점이다.
    이런 상황을 막기위해 C++은 메모리 재배치 순서를 강제할 수 있는 memory_order와 원자적 연산을 위한 atomic을 제공한다.
    atomic 의 메모리 관련 연산에 적절한 memory_order 를 지정해서 올바른 결과를 낼 수 있다.

    atomic에는 *가 없다. 곱셈 연산을 atomic하게 만들면 너무 비싸기 때문이다.
    덧셈 뺄셈 그리고 비트 연산들 (&, |, ^) 만 지원한다.
     
    CPU의 명령 실행 방식과 캐시로 인해 모든 쓰레드가 같은 자원을 공유해도 같은 시간에 같은 값을 얻는다는 보장은 없다.

    하지만 C++는 원자적 연산을 할 경우에 모든 쓰레드에서 같은 객체에 대해서 동일한 수정 순서(modification order) 를 관찰할 수 있다는 점을 보장하고 있다.
    (순서가 동일하다는 점이 중요하다)

    수정 순서(modification order)는 어떤 객체의 값을 실시간으로 확인할 수 있는 무언가가 있다고 했을 때
    해당 객체의 값의 변화를 기록한 것이다.(실제로 존재하지는 않고 가상의 수정 순서가 있다고 가정한 것이다.)

    모든 쓰레드에서 변수의 수정 순서에 동의한다면 같은 시간에 변수 a의 값을 관찰했다고 해서 모든 쓰레드들이 동일한 값을 관찰할 필요는 없다.
    즉 쓰레드1과 쓰레드2가 각각 5와 8을 관찰해도 문제가 없다.
    심지어, 동일한 코드를 각기 다른 쓰레드에서 실행했을때, 실행하는 순서가 달라도 결과만 같다면 문제될 건 없다.

    쓰레드 간의 같은 시간에 변수의 값을 읽었을 때 다른 값을 return해도 되는 이유는 CPU의 캐시가 각 코어별로 존재하기 때문이다.

    각 코어별로 L1, L2 캐시들을 가지고 있어 쓰레드1에서 a를 5로 바꾼 후 자신의 캐시에만 기록한 후 다른 코어에게 알리지 않는다면
    다른 쓰레드에서 a의 값을 확인했을 시 5를 얻는다는 보장이 없다.

    매번 값을 기록할 때 마다 모든 캐시에 동기화를 할 수는 있지만 시간을 많이 소모한다.
    하지만 C++은 low-level langauge로 세밀하게 조정가능한 도구들을 제공하고 있다.

    Atomicity
    모든 쓰레드들이 수정 순서에 동의해야만 하는 경우는 바로 모든 연산들이 원자적 일 때이다.
    원자적인 연산이 아닌 경우에는 모든 쓰레드에서 같은 수정 순서를 관찰할 수 있음이 보장되지 않기에
    직접 적절한 동기화 방법을 통해서 처리해야 한다.
    만일 이를 지키지 않는다면 프로그램이 정의되지 않은 행동(undefined behavior)을 할 수 있다.

    Atomicity(원자적)이란 CPU가 명령어 1개로 처리하는 명령으로, 중간에 다른 쓰레드가 끼어들 여지가 전혀 없는 연산을 말한다.
    이 연산을 반 정도 했다는 있을 수 없고 했다 또는 안했다만 존재한다.
    마치 원자처럼 쪼갤수 없다고 해 Atomicity(원자적)이라고 한다. (물론 실제로는 원자를 쪼갤 수 있다.)

    C++는 몇몇 타입들에 원자적인 연산을 쉽게할 수 있도록 여러가지 도구들을 지원하고 있다.
    이런 연산을 위해 굳이 mutex가 필요하지 않아 속도는 매우 빠르다.

*/
#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

// mutex를 하지 않았음에도 race condition 없이 똑바로 수행됬다.
void worker(std::atomic<int> &counter)
{
    for (int i = 0; i < 10000; i++)
    {
        // 어셈블리 코드, lock add DWORD PTR [rdi], 1   로 변환된다.
        // 메모리에 읽기 쓰기가 모두 가능한 명령어는 없지만 lock add는 rdi 메모리를 읽고 1을 더하고 쓰기까지 다한다.
        // 컴파일러는 어느 CPU 에서 실행할 지 (x86) 컴파일러가 알고 있기 때문에 이런 CPU 특이적인 명령어를 제공할 수 있었다.
        counter++;
    }
}

int main()
{
    // atomic 템플릿
    std::atomic<int> counter(0);

    std::vector<std::thread> workers;
    for (int i = 0; i < 4; i++)
    {
        workers.push_back(std::thread(worker, ref(counter)));
    }

    for (int i = 0; i < 4; i++)
    {
        workers[i].join();
    }

    std::atomic<int> x;

    // mutex의 lock 없이도 연산이 수행 가능한지 확인하는 함수이다.
    std::cout << "is lock free ? : " << boolalpha << x.is_lock_free() << std::endl;

    std::cout << "Counter 최종 값 : " << counter << std::endl;
}