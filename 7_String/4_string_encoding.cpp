// Unicode - 전세계 문자들을 표현하기 위해 설계된 표준, 모든 문자들에 고유값을 준다.
/*
    ex) 한글의 가는 0xAC00의 값을 부여받았고 각은 0xAC01이다.
    숫자와 영어는 기존 ASCII TABLE와의 호환성을 위해 기존과 같다.
    최근에는 이모지도 사용가능하다.

    현재 유니코드에 등록되어 있는 문자들의 개수는 대략 14 만 개 정도 되므로,
    문자 하나를 한 개의 자료형에 보관하기 위해서는 최소 int 를 사용해야된다. (1 바이트나 2 바이트로는 불가)

    하지만 모든 문자를 int, 4byte를 사용해 나타내는 것은 매우 비효율적이다.
    그래서 나온것이 Encoding 방식이다.
    Encoding 방식은 동일하게 4byte를 사용하는 대신 문자를 각 2, 4byte등 길이로 각각 저장한다.
    3가지 방법이 존재한다.

    1. UTF-8 : 문자를 최소 1부터 최대 4byte로 표현한다. (즉 문자마다 길이가 다르다), 웹상에서 많이 사용
        UTF-8 Encoding 방식
            예를 들어서 0 부터 0x7F 까지의 문자들은 1 바이트, 그 다음 0x80 부터 0x7FF 까지 문자들은 2 바이트,
            0x800 부터 0xFFFF 까지는 3 바이트, 그리고 나머지가 4 바이트로 지정
            한글의 경우 0xAC00 부터 0xD7AF 까지 걸쳐 있으므로 전부 3 바이트로 표현

    2. UTF-16 : 문자를 2혹은 4byte로 표현한다.
        숫자와 영어 등을 제외한 나머지는 1byte보다 크므로 대부분의 문자들이 UTF-16 방식으로 인코딩된다.
        UTF-16 은 유니코드에서 0 부터 D7FF 번 까지, 그리고 E000 부터 FFFF 까지의 문자들을 2 바이트로 인코딩한다.
        그리고 FFFF 보다 큰 문자들은 4 바이트로 인코딩된다
        참고로 D800 번 부터 DFFF 사이의 문자들은 이들은 유니코드 상 존재하지 않는 문자들이다.

    3. UTF-32 : 문자를 4byte로 표현한다. (모든 문자를 4byte로 할당해 사용하기 매우 쉽다.)
*/

#include <iostream>
#include <string>

int main()
{
    // UTF-32로 인코딩된 문자열 보관 타입, U는 이 literal를 UTF-32로 Encoding하라는 의미이다.
    //                         1234567890 123 4 567
    std::u32string u32_str = U"이건 UTF-32 문자열 입니다";
    std::cout << u32_str.size() << std::endl;

    // 대부분의 시스템의 경우 파일의 형식이 UTF-8이므로 u8을 안붙여줘도 된다.
    //                   12 345678901 2 3456
    // 한글(3byte) 8개 알파벳, 공백문자, - (1byte씩)가 총 8개 즉 3byte x 8 + 1byte x 8 = 32, 총 32개의 char이 필요해 size가 32가된다.
    std::string str = u8"이건 UTF-8 문자열 입니다";
    std::cout << str.size() << std::endl;

    /*
        std::string 은 문자열이 어떤 인코딩으로 이루져있는지 신경쓰지 않는다. 단순히 char의 나열이라 생각한다.
        따라서 str.size()는 문자열의 길이가 아닌 그냥 char이 몇개있는지를 알려줘 32가 되는 것이다.

        문제는 string은 각각의 문자를 구분하지 못한다.
        std::cout << str[1]; 은 UTF-8 인코딩의 두 번째 byte 값이 나오고 해당 값은 인코딩이 불가능해 이상한 값이 나올것이다.

        그래서 다른방식이 필요하다.
        하지만 size()를 제외한 나머지는 문자열 인코딩방식과 무관하므로 basic_string에 정의된 연산들을 사용할 수 있따.
    */
    //                   1 234567890 1 2 34 5 6
    std::string str = u8"이건 UTF-8 문자열 입니다";
    size_t i = 0;
    size_t len = 0;

    while (i < str.size())
    {
        int char_size = 0;

        // UTF-8 인코딩 방식을 살펴보면, 4 바이트로 인코딩되는 문자들은 첫 번째 바이트가 11110xxx 꼴이다
        // 결국 11111000 과 AND 연산을 했을 때 11110000 이 나오는 비트 형태는 11110xxx 형태 밖에 없어 분류를 한다.
        if ((str[i] & 0b11111000) == 0b11110000)
        {
            char_size = 4;
        }
        // 나머지 조건문도 비슷하다.
        else if ((str[i] & 0b11110000) == 0b11100000)
        {
            char_size = 3;
        }
        else if ((str[i] & 0b11100000) == 0b11000000)
        {
            char_size = 2;
        }
        else if ((str[i] & 0b10000000) == 0b00000000)
        {
            char_size = 1;
        }
        else
        {
            std::cout << "이상한 문자 발견!" << std::endl;
            char_size = 1;
        }

        // 문자의 시작 위치에서 char_size만큼 읽어와 제대로 인코딩된 문자를 출력할 수 있게 된다.
        std::cout << str.substr(i, char_size) << std::endl;

        i += char_size;
        len++;
    }
    std::cout << "문자열의 실제 길이 : " << len << std::endl;

    /*
        한글은 영어나 숫자와 달리 3byte를 사용하기에 UTF-8로는 문자열 다루는게 불편하다.
        그래서 UTF-16을 사용하는데 이 방식으로 대부분의 문자들이 인코딩된다.
    */
    //                         1234567890 123 4 567
    std::u16string u16_str = u"이건 UTF-16 문자열 입니다";

    // 대부분의 문자들이 2byte로 인코딩되므로 모든 문자들이 원소 1개만큼 사용해 size가 일치한다.
    std::cout << u16_str.size() << std::endl;

    // 따라서 초성만 분리하는 코드를 작성할 수도 있따.
    std::u16string u16_str = u"안녕하세용 모두에 코드에 오신 것을 환영합니다";
    std::string jaum[] = {"ㄱ", "ㄲ", "ㄴ", "ㄷ", "ㄸ", "ㄹ", "ㅁ",
                          "ㅂ", "ㅃ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅉ",
                          "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"};

    // 하지만 떄론 4byte로도 인코딩 되므로 str[i]같이 접근은 못한다.
    for (char16_t c : u16_str)
    {
        // 유니코드 상에서 한글의 범위
        if (!(0xAC00 <= c && c <= 0xD7A3))
        {
            continue;
        }
        // 한글은 AC00 부터 시작해서 한 초성당 총 0x24C 개 씩 있다.
        int offset = c - 0xAC00;
        int jaum_offset = offset / 0x24C;
        std::cout << jaum[jaum_offset];
    }
}